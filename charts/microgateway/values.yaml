# replicaCount -- Desired number of Microgateway pods.
replicaCount: 1

image:
  # image.repository -- Image repository for the Airlock Microgateway runtime image
  repository: ergon/airlock-microgateway-nightly
  # image.repository_configbuilder -- Image repository for the Airlock Microgateway configbuilder image
  repository_configbuilder: ergon/airlock-microgateway-configbuilder-nightly
  # image.tag -- Image tag for microgateway and configbuilder image
  tag: "2.0.sprint9_Build006"
  # image.pullPolicy -- Pull policy (`Always`, `IfNotPresent`, `Never`)
  pullPolicy: IfNotPresent

## Microgateway Config
##
config:
  # config.generic --
  # @default -- See `config.generic.*`:
  generic:
    # config.generic.configEnv -- [DSL Environment Variables](#dsl-environment-variables)
    configEnv: []
    # config.generic.runtimeEnv -- [Runtime Environment Variables](#runtime-environment-variables)
    runtimeEnv: []
    # config.generic.tlsSecretName -- (string) Name of an existing secret containing:<br><br>
    # _Virtual Host:_<br>
    # Certificate: `frontend-server.crt`<br>
    # Private key: `frontend-server.key`<br>
    # CA: `frontend-server-ca.crt` <br>
    # :exclamation: Update `route.tls.destinationCACertificate` accordingly.<br><br>
    # _Backend:_<br>
    # Certificate: `backend-client.crt`<br>
    # Private key: `backend-client.key`<br>
    # CA: `backend-server-validation-ca.crt`
    # @default -- ""
    tlsSecretName:
    # config.generic.passphrase -- Passphrase used for encryption.
    # @default -- - `passphrase`<br> If `passphrase` in `config.generic.existingSecret` <br><br> - `<generated passphrase>`<br> If no passphrase available.
    passphrase:
    # config.generic.license -- (string) License (multiline string)
    # @default -- ""
    license:
    # config.generic.existingSecret -- (string) Name of an existing secret containing:<br><br>
    # license: `license`<br>
    # passphrase: `passphrase`
    # @default -- ""
    existingSecret:

  # config.dsl -- [DSL configuration](#dsl-configuration)
  dsl: {}

# commonLabels -- Labels to add to all resources.
commonLabels: {}
# imagePullSecrets -- Reference to one or more secrets to use when pulling images.
imagePullSecrets: []
  # - name: "image-pull-secret"
# imageCredentials -- Creates a imagePullSecret with the provided values.
imageCredentials:
  # imageCredentials.enabled -- Enable the imagePullSecret creation.
  enabled: false
  # imageCredentials.registry -- imagePullSecret registry
  registry: "https://index.docker.io/v1/"
  # imageCredentials.username -- imagePullSecret username
  username: ""
  # imageCredentials.password -- imagePullSecret password/Token
  password: ""
# nameOverride -- Provide a name in place of `microgateway`.
nameOverride: ""
# fullnameOverride -- Provide a name to substitute for the full names of resources.
fullnameOverride: ""
# podSecurityContext -- [Security context for the pods](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod).
podSecurityContext: {}
  # fsGroup: 2000
# securityContext -- [Security context for a container](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container).
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # runAsUser: 1000

# serviceAccount -- Specifies the service account under which the microgateway will run.
# A dedicated service account is created and used by default. <br><br>
# If `serviceAccount.create=true` and no `serviceAccount.name` is given, a name is generated using the fullname template. <br><br>
# If `serviceAccount.create=false` and no `serviceAccount.name` is given, the microgateway runs under the default service account.
serviceAccount:
  # serviceAccount.create -- Specifies whether a ServiceAccount should be created
  create: true
  # serviceAccount.name -- The name of the ServiceAccount to use. <br><br>
  name:
  # serviceAccount.annotations -- Annotations to set on the service account.
  annotations: {}
  # serviceAccount.labels -- Additional labels added on the service account.
  labels: {}
service:
  # service.type -- [Service type](https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types)
  type: ClusterIP
  # service.externalTrafficPolicy -- [externalTrafficPolicy](https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip)
  # @default -- `Local` if `service.type=LoadBalancer`
  externalTrafficPolicy: Local
  # service.loadBalancerIP -- [loadBalancerIP](https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer)
  # @default -- "" if `service.type=LoadBalancer`
  loadBalancerIP:
  # service.port -- Service port
  port: 80
  # service.tlsPort -- Service TLS port
  tlsPort: 443
  # service.annotations -- Annotations to set on the service.
  annotations: {}
    # service.alpha.openshift.io/serving-cert-secret-name: microgateway
  # service.labels -- Additional labels to add on the service.
  labels: {}

# ingress -- [Kubernetes Ingress](#kubernetes-ingress)
# @default -- See `ingress.*`:
ingress:
  # ingress.enabled -- Create an ingress object.
  enabled: false
  # ingress.annotations -- Annotations to set on the ingress.
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    # kubernetes.io/tls-acme: "true"
    # kubernetes.io/ingress.class: nginx
    ## For reencrypt ingress, see https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#backend-certificate-authentication
    # nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    # nginx.ingress.kubernetes.io/proxy-ssl-verify: "true"
    # nginx.ingress.kubernetes.io/proxy-ssl-secret: secretName
  # ingress.labels -- Additional labels to add on the Microgateway ingress.
  labels: {}
  # ingress.hosts -- List of ingress hosts.
  hosts:
    - virtinc.com
  # ingress.path -- Path for the ingress.
  path: /
  # ingress.targetPort -- Target port of the service (`http`, `https` or `<number>`).
  targetPort: http

  # ingress.tls -- [Ingress TLS](https://kubernetes.io/docs/concepts/services-networking/ingress/#tls) configuration.
  tls: []
  #  - secretName: virtinc-tls
  #    hosts:
  #      - virtinc.com

## OpenShift route configuration.
## ref: https://docs.openshift.com/container-platform/3.11/architecture/networking/routes.html
# route -- [Openshift Route](#openshift-route)
# @default -- See `route.*`:
route:
  # route.enabled -- Create a route object.
  enabled: false
  # route.annotations -- Annotations to set on the route.
  annotations: {}
    # kubernetes.io/tls-acme: "true"
    # haproxy.router.openshift.io/disable_cookies: "true"
    # haproxy.router.openshift.io/balance: roundrobin
  # route.labels -- Additional labels add on the Microgateway route.
  labels: {}
  # route.hosts --  List of host names. <br>
  # A route will be created for every host name listed. No route will be created
  # if no hosts are specified.
  # Use an empty string to generate a route without hostname.
  hosts:
    - virtinc.com
  # route.path -- Path for the route.
  path: /
  # route.targetPort -- Target port of the service (`http`, `https` or `<number>`).
  targetPort: https

  ## TLS configuration
  ## ref: https://docs.openshift.com/container-platform/3.11/architecture/networking/routes.html#secured-routes
  ##
  tls:
    # route.tls.enabled -- Enable TLS for the route.
    enabled: true
    # route.tls.insecureEdgeTerminationPolicy -- Define the insecureEdgeTerminationPolicy of the route (`Allow`, `Redirect`, `None`).
    insecureEdgeTerminationPolicy: Redirect
    # route.tls.termination -- Termination of the route (`edge`, `reencrypt`, `passthrough`).
    termination: reencrypt
    # route.tls.certificate -- Certificate to be used (multiline string).
    # @default -- ""
    certificate:  # |
      # -----BEGIN CERTIFICATE-----
      # -----END CERTIFICATE-----
    # route.tls.key -- Private key to be used for certificate (multiline string).
    # @default -- ""
    key:  # |
      # -----BEGIN RSA PRIVATE KEY-----
      # -----END RSA PRIVATE KEY-----
    # route.tls.destinationCACertificate -- Validate the Microgateway server certificate
    # against this CA. (multiline string).<br>
    # :exclamation: Must be configured with termination `reencrypt`.
    # @default -- Microgateway's default certificate
    destinationCACertificate: |
      -----BEGIN CERTIFICATE-----
      MIIDizCCAnOgAwIBAgIJAMQE1QewYs4QMA0GCSqGSIb3DQEBCwUAMFwxCzAJBgNV
      BAYTAkNIMQ8wDQYDVQQIDAZadXJpY2gxDzANBgNVBAcMBlp1cmljaDEQMA4GA1UE
      CgwHQWlybG9jazEZMBcGA1UEAwwQdGVzdC5jZXJ0aWZpY2F0ZTAeFw0xNjAyMTYx
      NTE4NTZaFw0yNjAyMTUxNTE4NTZaMFwxCzAJBgNVBAYTAkNIMQ8wDQYDVQQIDAZa
      dXJpY2gxDzANBgNVBAcMBlp1cmljaDEQMA4GA1UECgwHQWlybG9jazEZMBcGA1UE
      AwwQdGVzdC5jZXJ0aWZpY2F0ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
      ggEBAMtPaJ5q3HFeui6iKe5i9gBjAuZwbZ5a05MVbj0NnyCm6iOcuJOySUAPM2kF
      JqUxrIXdz54xcilsKUoepQkn9e0bmIUVuiXWcQrr8iqjYC+hINNmiq+4YX4lWq2M
      CeOSOpxrMPmvDX0kt+O9Qwr+6tTqzD5VKJDFvlrfJnYTQ4WXeiaG9SfgR06/+pSQ
      +qDRWo7JmrVHcyv+3X0aRZ2JUP9cFy054GxF3dhRaZMZ7KdgjX5FkADY8MYiI2j5
      9Q2SA8zBjfRfZlGCORm7vdwIzPbRRo19TMXeBoOOnO8XB/XWS+n/bBLkRYN+wcnf
      tPZZuLggCQhRBVHy9ehKltkJMZkCAwEAAaNQME4wHQYDVR0OBBYEFP4M/uLWVuOh
      8RkBDnlU5jJyR3cJMB8GA1UdIwQYMBaAFP4M/uLWVuOh8RkBDnlU5jJyR3cJMAwG
      A1UdEwQFMAMBAf8wDQYJKoZIhvcNAQELBQADggEBAKItccRGDcX9pdkiHv/1PQtb
      ykmxAMseVYt/6kJl3yUUd/tDTaAR4CHTvkX+4waMpnhToJ3SN9qNtbzID1/67X6D
      9RQAaiXiJ0Y+/Z6cWY/Rx3HiWsgcJN7F0Xux6wR5gdX/oSCqxyomxR42Ovs61bjx
      77RRptcoQJPvw50z9rJ4wkrb58raUKOqxgvpckQdYdtok0dR6tXbBfC4LHmqq0mo
      Q4ph1jI/QLl5lsYtDm4SLt1ALvgRQj8QerJdZ/SrmfFmUkOx3lGpBChM0lT+wkrI
      aw/GIcvwLSquzFBrlU3Jhg+wu8p/514lgiShy39fmzMOa3Q0/5jF3qM74+lGUsA=
      -----END CERTIFICATE-----
# resources -- Resource requests for the runtime container. [Resource limits](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container)
resources:
  requests:
    memory: 256Mi
    cpu: 30m
  limits:
    memory: 4048Mi
# initResources -- Resource requests for the init container. [Resource limits](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container)
initResources:
  requests:
    memory: 256Mi
    cpu: 30m
  limits:
    memory: 512Mi
    cpu: 1000m

## Liveness and readiness probe values
## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
##
livenessProbe:
  # livenessProbe.enabled -- Enable liveness probes.
  enabled: true
  # livenessProbe.initialDelaySeconds -- Initial delay in seconds.
  initialDelaySeconds: 90
  # livenessProbe.failureThreshold -- After how many subsequent failures the pod gets restarted.
  failureThreshold: 9
  # livenessProbe.timeoutSeconds -- Timeout of liveness probes, should roughly reflect allowed timeouts from clients.
  timeoutSeconds: 5

readinessProbe:
  # readinessProbe.enabled -- Enable readiness probes.
  enabled: true
  # readinessProbe.initialDelaySeconds -- Initial delay in seconds.
  initialDelaySeconds: 10
  # readinessProbe.failureThreshold -- After how many tries the pod stops receiving traffic.
  failureThreshold: 3

# nodeSelector -- Define which nodes the pods are scheduled on.
nodeSelector: {}
# tolerations -- Tolerations for use with node [taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/).
tolerations: []

# affinity -- (string) Assign custom [affinity rules](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/) (multiline string).
affinity:
  # podAntiAffinity:
  #   requiredDuringSchedulingIgnoredDuringExecution:
  #     - labelSelector:
  #         matchLabels:
  #           {{- include "microgateway.selectorLabels" . | nindent 10 }}
  #       topologyKey: kubernetes.io/hostname

# extraVolumes -- Add additional volumes. [Volumes](https://kubernetes.io/docs/concepts/storage/volumes/)
extraVolumes: []
    # - name: volumename
    #   configMap:
    #     name: config-map-name
# extraVolumeMounts -- Add additional volume mounts.
extraVolumeMounts: []
    # - name: mountname
    #   mountPath: /path/file.yaml

# redis -- Pre-configured [Redis](#redis) service.
# @default -- See `redis.*`:
redis:
  # redis.enabled -- Deploy pre-configured [Redis](#redis).
  enabled: false
  fullnameOverride: redis
  securityContext:
    enabled: false
  cluster:
    enabled: false
  usePassword: false
  master:
    disableCommands: []
    # do not disable any commands since Microgateway needs full control
    # to configure the redis session store.
    persistence:
      enabled: false

# echo-server -- Pre-configured [Echo-Server](#echo-server).
# @default -- See `echo-server.*`:
echo-server:
  # echo-server.enabled -- Deploy pre-configured [Echo-Server](#echo-server).
  enabled: false
  fullnameOverride: backend
  service:
    port: 8080

# hpa -- [Horizontal Pod Autoscaler](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/) to scale <br>
# Microgateway based on Memory and CPU consumption.<br><br>
# :exclamation: Check [API versioning](https://kubernetes.io/docs/concepts/overview/kubernetes-api/#api-versioning) when using this Beta feature.
# @default -- See `hpa.*`:
hpa:
  # hpa.enabled -- Deploy a horizontal pod autoscaler.
  enabled: false
  # hpa.maxReplicas -- Maximum number of Microgateway replicas.
  maxReplicas: 10
  # hpa.minReplicas -- Minimum number of Microgateway replicas.
  minReplicas: 1
  resource:
    # hpa.resource.memory -- Average Microgateway Memory consumption to scale up/down.<br><br>
    # :exclamation: Update this setting accordingly to `resources.limits.memory`.
    memory: 2Gi
    # hpa.resource.cpu -- Average Microgateway CPU consumption in percentage to scale up/down.
    cpu: 50
# test_request -- Request that will be used as a smoketest when 'helm test' is invoked.
test_request: /
